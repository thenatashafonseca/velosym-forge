/**
 * Each rule: scan a line (with context) and return a violation or null.
 */

export interface Violation {
  rule: string;
  message: string;
  line: number;
  text: string;
}

export interface Rule {
  name: string;
  check(line: string, lineNum: number, allLines: string[]): Violation | null;
}

const redundantCommentPattern =
  /^\s*\/\/\s*(this\s+(function|method|class|variable|constant|module)\s+(is|does|will|returns|takes|handles|creates|gets|sets|checks|validates|processes))/i;

const obviousCommentPatterns = [
  /^\s*\/\/\s*import(s|ing)?\s/i,
  /^\s*\/\/\s*export(s|ing)?\s/i,
  /^\s*\/\/\s*define\s/i,
  /^\s*\/\/\s*declare\s/i,
  /^\s*\/\/\s*set(ting|s)?\s+(the\s+)?(value|variable|state)/i,
  /^\s*\/\/\s*return(s|ing)?\s+(the\s+)?(result|value|output|response)/i,
  /^\s*\/\/\s*loop(ing|s)?\s+(through|over)/i,
  /^\s*\/\/\s*iterate\s+(through|over)/i,
  /^\s*\/\/\s*check(s|ing)?\s+if/i,
  /^\s*\/\/\s*initialize/i,
  /^\s*\/\/\s*constructor/i,
];

const slopPhrases = [
  /^\s*\/\/\s*TODO:\s*implement/i,
  /^\s*\/\/\s*auto[- ]generated/i,
  /^\s*\/\/\s*generated by/i,
  /^\s*\/\/\s*eslint-disable/,
  /^\s*\/\*\s*eslint-disable\s*\*\//,
];

export const rules: Rule[] = [
  {
    name: "no-redundant-comment",
    check(line, lineNum) {
      if (redundantCommentPattern.test(line)) {
        return { rule: this.name, message: "Redundant comment describes what code already says", line: lineNum, text: line.trim() };
      }
      for (const pat of obviousCommentPatterns) {
        if (pat.test(line)) {
          return { rule: this.name, message: "Comment states the obvious", line: lineNum, text: line.trim() };
        }
      }
      return null;
    },
  },
  {
    name: "no-slop-markers",
    check(line, lineNum) {
      for (const pat of slopPhrases) {
        if (pat.test(line)) {
          return { rule: this.name, message: "AI slop marker detected", line: lineNum, text: line.trim() };
        }
      }
      return null;
    },
  },
  {
    name: "no-excessive-comments",
    check(line, lineNum, allLines) {
      // Flag files where >40% of lines are comments (checked on last line only)
      if (lineNum !== allLines.length) return null;
      const commentLines = allLines.filter((l) => /^\s*(\/\/|\/\*|\*)/.test(l)).length;
      const ratio = commentLines / allLines.length;
      if (ratio > 0.4 && allLines.length > 10) {
        return { rule: this.name, message: `${Math.round(ratio * 100)}% of lines are comments â€” excessive for production code`, line: lineNum, text: "(file-level)" };
      }
      return null;
    },
  },
];
